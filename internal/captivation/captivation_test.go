package captivation

import (
	"bytes"
	"sync"
	"testing"

	"github.com/pt-arvind/DeveloperChallenge/internal/logger"
)

// using https://www.rapidtables.com/convert/number/ascii-to-binary.html to write test cases

const PREAMBLE = "0100001101000001010100000101010001001001010101100100000101010100010010010100111101001110"

// TestLessThan100AfterPreamble tests what happens when there's less than 100 characters after the start of the message
func TestLessThan100AfterPreamble(t *testing.T) {
	//CAPTIVATIONblahblahblahblahb
	input := []byte("01000011010000010101000001010100010010010101011001000001010101000100100101001111010011100110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010")
	expected := "blahblahblahblahb"

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)

	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)

	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
}

// TestBasicInputMessage tests the basic case of CAPTIVATION followed by 100 characters
func TestBasicInputMessage(t *testing.T) {
	//CAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah
	input := []byte("010000110100000101010000010101000100100101010110010000010101010001001001010011110100111001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000")
	expected := "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah"

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)

	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)

	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
}

// TestBasicInputMessageWithExtraTrailingCharacters tests the basic case of CAPTIVATION followed by 100 characters followed by extra characters that ought not be printed
func TestBasicInputMessageWithExtraTrailingCharacters(t *testing.T) {
	//CAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahNONONONONO
	input := []byte("01000011010000010101000001010100010010010101011001000001010101000100100101001111010011100110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001001110010011110100111001001111010011100100111101001110010011110100111001001111")
	expected := "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah"

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)
	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)
	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
}

// TestBasicInputWithMultipleMessages tests the basic case of CAPTIVATION followed by 100 characters followed by padding, then another CAPTIVATION message
func TestBasicInputWithMultipleMessages(t *testing.T) {
	//CAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahNONONONONOCAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahNONONONONO
	input := []byte("0100001101000001010100000101010001001001010101100100000101010100010010010100111101001110011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000100111001001111010011100100111101001110010011110100111001001111010011100100111101000011010000010101000001010100010010010101011001000001010101000100100101001111010011100110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001001110010011110100111001001111010011100100111101001110010011110100111001001111")
	expected := "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah"

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)
	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)
	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
}

// TestMisalignedInputMessage tests the case where there's 5 padding bits then a valid message
func TestMisalignedInputMessage(t *testing.T) {
	//(pad5=01010)CAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahNONONO
	input := []byte("01010010000110100000101010000010101000100100101010110010000010101010001001001010011110100111001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000010011100100111101001110010011110100111001001111")
	expected := "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah"

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)
	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)
	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
}

// TestNestedMessages tests what happens when the preamble CAPTIVATION appears twice within the message itself
func TestNestedMessages(t *testing.T) {
	//CAPTIVATIONblahCAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahmsg2NONONONONO
	input := []byte("01000011010000010101000001010100010010010101011001000001010101000100100101001111010011100110001001101100011000010110100001000011010000010101000001010100010010010101011001000001010101000100100101001111010011100110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110110101110011011001110011001001001110010011110100111001001111010011100100111101001110010011110100111001001111")
	expected := "blahCAPTIVATIONbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbbllaahhbblahblahblahmsg2"

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)
	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)
	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
}

// TestPartialPreambleInput tests the case where most of captivation appears but not all
func TestPartialPreambleInput(t *testing.T) {
	//CAPTIVTIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah
	input := []byte("0100001101000001010100000101010001001001010101100101010001001001010011110100111001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000")
	expected := ""

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)
	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)
	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
}

// TestMultipleMessages tests what happens when the buffer is written to after being read
func TestMultipleMessages(t *testing.T) {
	//CAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahNONONONONO
	input := []byte("01000011010000010101000001010100010010010101011001000001010101000100100101001111010011100110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001001110010011110100111001001111010011100100111101001110010011110100111001001111")
	expected := "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah"

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)
	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)
	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}

	//CAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahNONONONONO
	input = []byte("01000011010000010101000001010100010010010101011001000001010101000100100101001111010011100110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001001110010011110100111001001111010011100100111101001110010011110100111001001111")
	expected = "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah"

	inBuf.Write(input)
	ProduceBits(log, &inBuf, consumer, &wg)

	wg.Wait()
	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
}

// TestMultipleMessages tests what happens when the buffer is written to after being read when the first message isn't complete
func TestMultipleMessagesMidMessage(t *testing.T) {
	//CAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah
	input := []byte("0100001101000001010100000101010001001001010101100100000101010100010010010100111101001110011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000")
	expected := "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah"

	var outBuf bytes.Buffer
	var inBuf bytes.Buffer
	log := &logger.LogWrapper{DebugMode: true}
	consumer := make(chan byte, 16) // buffered channel size 16
	var wg sync.WaitGroup
	inBuf.Write(input)
	go ProcessMessages(log, PREAMBLE, consumer, &outBuf, &wg)
	ProduceBits(log, &inBuf, consumer, &wg)
	wg.Wait()

	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}
	//prevCAPTIVATIONblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah
	input = []byte("011100000111001001100101011101100100001101000001010100000101010001001001010101100100000101010100010010010100111101001110011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000011000100110110001100001011010000110001001101100011000010110100001100010011011000110000101101000")
	expected = "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahprevblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah"

	inBuf.Write(input)

	ProduceBits(log, &inBuf, consumer, &wg)
	wg.Wait()
	if outBuf.String() != expected {
		t.Errorf("result was incorrect, got: %v, want: %v", outBuf.String(), expected)
	}

}
